##################################################
#
# Protocol File
#
# Protocol file for Keithley 2700
##################################################


##################################################
# General Settings
##################################################

Terminator = '\r\n';
ReplyTimeout = 2000;


###################################################
# Get functions

# <clist> (e.g. @101: %d)
# clist = @SCH 
# S = slot number (1 or 2)
# CH = switching module channel number
# @101,203 = slot 1, channel 1 AND slot 2, channel 3
# @101:110 = slot 1, channel1 to channel10


# Resistance = two ohms/wire resistance
# FResistance = four ohms/wire resistance
# 
###################################################



getIDN {
    out "*IDN?";
    #Read no more that 39 chars (EPICS limit)
    in "%/(.{0,39})/";
}

# empty buffer of readings (TRACE CLEAR)
# in emulator this would empty the buffer
# does this link to a pv..?
clearBuffer{
    out "TRAC:CLE";
}

# Select RESistance function
# // ADD @101 CHANNEL THING?
setResistanceMode{
    out "FUNC '%{RES|FRES}', (@101:%d)";
}

# buffer source: raw, calculated or none (none disables buffer storage)
setBufferFeedSource{
	out "TRAC:FEED %{SENS|CALC|NONE}"
}

getBufferFeedSource{	
	out "TRAC:FEED?";
	in "%{SENS|CALC|NONE}"
}

setBufferAutoClearStatus {
   out "TRAC:CLE:AUTO %{ON|OFF}";
}

# /// Query state of buffer auto-clear (ON/OFF)
getBufferAutoClearStatus {
   out "TRAC:CLE:AUTO?";
   in "%{ON|OFF}";
}

# Returns buffer location of next reading
getNextBufferReadingLoc {
    ExtraInput = Ignore;
    out "TRAC:NEXT?";
    in "%d";
}

# returns mem available (in bytes), number of bytes in use

getBufferMemory {
    ExtraInput = Ignore;
    out "TRAC:FREE?";
    in "%d,%(\$1)d";
}

# Select buffer control mode (NEVer, NEXT, or ALWays)
# next enables buffer, always places buffer into continuous filling mode
# never disable buffer operation
setBufferControl{
	out "TRAC:FEED:CONT %{NEV|NEXT|ALW}";
}

getBufferControl{
    out "TRAC:FEED:CONT?";
    in "%{NEV|NEXT|ALW}";
}

# TRACe DATA SELected (from start point(1) + count(2) )
getBuffReadRange{
    out "TRAC:DATA:SEL? %(\$1)d,%(\$2)d";  
    in "%s";
}

# size of buffer between 2 and 55000, default 100
# useable when buffer auto:clear enabled (when disabled, defaults to 55,000)
getBufferSize{
    ExtraInput = Ignore;
    out "TRAC:POIN?";
    in "%d";

}

# /// Specify size of buffer
setBufferSize{
	out "TRAC:POIN %d";
}


# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>




