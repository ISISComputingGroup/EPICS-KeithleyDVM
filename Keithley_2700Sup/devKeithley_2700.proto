##################################################
#
# Protocol File
#
# Protocol file for Keithley 2700
##################################################


##################################################
# General Settings
##################################################

Terminator = '\r\n';
ReplyTimeout = 2000;


###################################################
# Get functions

# <clist> (e.g. @101: %d)
# clist = @SCH 
# S = slot number (1 or 2)
# CH = switching module channel number
# @101,203 = slot 1, channel 1 AND slot 2, channel 3
# @101:110 = slot 1, channel1 to channel10


# Resistance = two ohms/wire resistance
# FResistance = four ohms/wire resistance
# 
###################################################



getIDN {
    out "*IDN?";
    #Read no more that 39 chars (EPICS limit)
    in "%/(.{0,39})/";
}


# clear messages from error queue
clearSystemErrors{
    out ":SYST:CLE";
}

# empty buffer of readings (TRACE CLEAR)
# in emulator this would empty the buffer
# does this link to a pv..?
clearBuffer{
    out "TRAC:CLE";
}

# set measurement function
# // ADD @101 CHANNEL THING?
setMeasurement {
    out ":FUNC '%{VOLT|VOLT:AC|CURR|CURR:AC|RES|FRES|CONT|FREQ|PER}', (\@101:210)";
}

# buffer source: raw, calculated or none (none disables buffer storage)
setBufferFeedSource{
	out "TRAC:FEED %{SENS|CALC|NONE}"
}

# Select buffer control mode (NEVer, NEXT, or ALWays)
# next enables buffer, always places buffer into continuous filling mode
# never disable buffer operation
setBufferControl{
	out "TRAC:FEED:CONT %{NEV|NEXT|ALW}";
}


setBufferAutoClearStatus {
   out "TRAC:CLE:AUTO %{ON|OFF}";
}


# Returns buffer location of next reading
getNextBufferReadingLoc {
    ExtraInput = Ignore;
    out "TRAC:NEXT?";
    in "%d";
}

# returns mem available (in bytes), number of bytes in use

getBufferMemory {
    ExtraInput = Ignore;
    out "TRAC:FREE?";
    in "%d,%(\$1)d";
}



# TRACe DATA SELected (from start point(1) + count(2) )
getBuffReadRange{
    out "TRAC:DATA:SEL? %(\$1)d,%(\$2)d";  
    in "%s";
}

# size of buffer between 2 and 55000, default 100
# useable when buffer auto:clear enabled (when disabled, defaults to 55,000)

setBufferSize{
	out "TRAC:POIN %d";
}

# timestamp format - ABSolute or DELTa defailt abs
# changing time stamp clears buffer
# time stamp only included in readings if specified in form:elems
setTimeStamp {
	out "TRAC:TST:FORM %{ABS|DELT}";
}

# set auto delay on/off
setTriggerDelayMode {
   out "TRIG:DEL:AUTO %{ON|OFF}";
}

# Query state of delay
getTriggerDelayMode {
   ExtraInput = Ignore;
   out "TRIG:DEL:AUTO?";
   in "%{ON|OFF}";
}


#  Enable or disable continuous initiation
# rst default is off
setInitState{
	out "INIT:CONT %{ON|OFF}";
}

# Query continuous initiation
getInitState{
	ExtraInput = Ignore;
	out "INIT:CONT?";
	in "%{ON|OFF}";
}

# Set Sample Count (1 to 55000)
# default is 1
setSampleCount{
	out "SAMP:COUN %d";
}

getSampleCount{
	ExtraInput = Ignore;
	out "SAMP:COUN?";
	in "%d";	
}


}
# Select Control Source (IMMediate, TIMer, MANual, BUS, or EXTernal).
setControlSource{
	out "TRIG:SOUR %{IMM|TIM|MAN|BUS|EXT}";
}

# Specify elements for TRACe:DATA:SEL response: READing, CHANnel, UNITSs, RNUMber, TSTamp 
# >>>>>>>>> Can you pass through multiples values of %{READ|CHAN|TST} ?
setDataElements{
    out "FORM:ELEM READ, CHAN, TST";
}

setDataReadChanTstUnitRnum {
	out "FORM ELEM READ, CHAN, TST, UNIT, TST";
}

# set auto range on/off (it selects best range to measure signal)

setAutoRange {
    out "FRES:RANG:AUTO %{ON|OFF}, (\@101:210)";
}

# number of digits for f-resistance (4-7)
setFResDigits {
	out ":FRES:DIG %d, (\@101:210)"
}

# set number of f-resistance plc cycles (higher = longer reading time,
# default = 5.0)
setFResistancePlcRate{
	out ":FRES:NPLC %f";
}

# enable/disable scan
setScanState{
	out "ROUT:SCAN:LSEL %{INT|NONE}";
}




# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>




